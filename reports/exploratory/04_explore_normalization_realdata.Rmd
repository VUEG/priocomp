---
title: Comparing prioritization methods
date: "May 22, 2016"
output: html_notebook
---

```{r setup, echo=FALSE,message=FALSE,warning=FALSE}
library(grid)
library(gridExtra)
library(protectr)
library(raster)
library(rasterVis)
library(viridis)
library(zonator)
```

```{r function-defintions,echo=TRUE}

normalize <- function(x) {
  min <- raster::minValue(x)
  max <- raster::maxValue(x)
  return((x - min) / (max - min))
}

ol_normalize <- function(x) {
  min <- raster::minValue(x)
  return((x - min) / raster::cellStats(x - min, "sum"))
}

standardize <- function(x) {
  mean <- raster::cellStats(x, "mean")
  sd <- raster::cellStats(x, "sd", asSample = FALSE)
  return((x - mean) / sd)
}

IQRize <- function(x) {
  x_values <- raster::getValues(x)
  med <- median(x_values)
  iqr <- IQR(x_values, na.rm = TRUE)
  return((x - med) / iqr)
}

```

## 1. Setup and background

### 1.1 Zonation tutorial data

```{r read-feature,echo=TRUE}
z_tutorial_dir <- "~/dev/git-data/zonation-tutorial"
z_tutorial_data_dir <- file.path(z_tutorial_dir, "data")
tutorial_files <- list.files(path = z_tutorial_data_dir, pattern = "species.+\\.tif", 
                             full.names = TRUE)
sp_rasters <- raster::stack(tutorial_files)
levelplot(sp_rasters, margin = FALSE, col.regions = viridis, layout = c(3, 3))
```

### 1.2 Geneate cost data

```{r generate-cost-data}

nrows <- nrow(sp_rasters)
ncols <- ncol(sp_rasters)

r <- extent(sp_rasters) %>% 
    raster(nrows = nrows, ncols = ncols, vals = 1)

cost <- extent(sp_rasters) %>% 
  raster(nrows = nrows, ncols = ncols, vals = 1)
#cost <- gaussian_field(r, 20, mean = 1000, variance = 500) #%>% 
#  setNames("cost")
levelplot(cost, main = "Cost", margin = FALSE, col.regions = viridis)
```

## 2. Pririoritization methods

### 2.1 Rarity-Weighted Richness (RWR)

```{r normalize-everything,echo=TRUE}
ol_sp_rasters <- ol_normalize(sp_rasters)
sum_sp_rasters <- sum(ol_sp_rasters, na.rm = TRUE)
# Replace 0 with NA
sum_sp_rasters[sum_sp_rasters ==  0] <- NA
ranks <- rank(raster::getValues(sum_sp_rasters), ties.method = "random", na.last = "keep")
# Scale to range [0, 1]
ranks <- ranks / max(ranks, na.rm = TRUE)
e <- raster::extent(sp_rasters)
rank_sp_rasters <- raster(e, nrows = nrow(sum_sp_rasters), ncols = ncol(sum_sp_rasters),
                           vals = ranks)

z_colors_spectral <- zonator::zlegend('spectral')
z_colors_RdYlBu <- z_colors_spectral
z_colors_RdYlBu$colors <- rev(brewer.pal(7, "RdYlBu"))  
```
```{r plot-rwr, echo=FALSE}
(p1 <- levelplot(rank_sp_rasters, margin = FALSE, main = "RWR",
                 par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                 at = z_colors_RdYlBu$values))
```

### 2.2 Zonation (CAZ + ABF)

```{r read-in-caz-results, echo=FALSE}
caz_rank <- raster(file.path(z_tutorial_dir, "basic", "basic_output", 
                             "01_core_area_zonation", "01_core_area_zonation.rank.asc"))
(p2 <- (levelplot(caz_rank, margin = FALSE,
                  par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                  at = z_colors_RdYlBu$values, main = "Core-area Zonation")))
```

```{r read-in-abf-results, echo=FALSE}
abf_rank <- raster(file.path(z_tutorial_dir, "basic", "basic_output", 
                             "02_additive_benefit_function", 
                             "output_02_additive_benefit_function.rank.asc"))
(p3 <- levelplot(abf_rank, margin = FALSE,
                 par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                 at = z_colors_RdYlBu$values, main = "Additive benefit function"))
```

### 2.3 Prioritization based on Gurobi MILP


```{r optimize}

set_targets <- function(x, features, type = c("percent", "absolute")) {
  type <- match.arg(type)
  assert_that(inherits(features, "RasterStack"),
              is.numeric(x),
              length(x) == 1 || length(x) == nlayers(features))
  
  # total representation level
  total <- unname(cellStats(features, "sum"))
  if (type == "percent") {
    assert_that(all(x >= 0), all(x <= 1))
    return(x * total)
  } else {
    assert_that(length(x) == nlayers(x), all(x >= 0), all(x <= target))
    return(x)
  }
}

# From http://strimas.com/r/gurobi/

gurobi_solve <- function(features, cost, targets, blm, edge_factor = 1,
                         target_type = c("percent", "absolute"),
                         gap = 0.005, time_limit = Inf) {
  # check inputs
  assert_that(inherits(features, "RasterStack"),
              inherits(cost, "RasterLayer"),
              compareRaster(cost, features),
              is.number(blm), blm >= 0,
              is.number(edge_factor),
              is.number(gap), gap >= 0)
  
  # set proportional targets or check absolute targets
  target_type <- match.arg(target_type)
  targets <- set_targets(targets, features, type = target_type)
  # linear component of objective function
  obj <- cost[]
  if (blm > 0) {
    # calculate boundaries
    bound <- protectr::calculate_boundary(cost, sep_diagonal = TRUE)
    obj <- obj + blm * row_sums(bound$off_diagonal)
    # edge external, edge boundaries if edge_factor = 0
    if (edge_factor != 0) {
      obj <- obj + blm * edge_factor * bound$diagonal
    } 
  }
  
  # construct model
  model <- list()
  # goal is to minimize objective function
  model$modelsense <- "min"
  # binary decision variables
  model$vtype <- "B"
  # objective function
  model$obj <- obj
  if (blm > 0) {
    model$Q <- -blm * bound$off_diagonal
    rm(bound)
  }
  # structural constraints
  model$A <- as.simple_triplet_matrix(t(features[]))
  model$rhs <- targets
  model$sense <- rep('>=', length(targets))

  # set the parameters that control the algorithm
  # MIPGap controls the how close the returned solution is to optimality
  params <- list(Presolve = 2)
  if (is.finite(time_limit)) {
    params$TimeLimit = time_limit
  } else {
    params$MIPGap = gap
  }
  
  # gurobi is very RAM hungry, remove any un-needed objects
  rm(features, cost, targets, obj)
  
  # solve
  gurobi(model, params)
}

# NAs (NoData) must be raplaced wiht 0s for GUROBI
sp_rasters_filled <- sp_rasters
sp_rasters_filled[is.na(sp_rasters_filled)] <- 0
sp_rasters_filled <- raster::stack(sp_rasters_filled)

blm = 0
target = 0.1
results <- gurobi_solve(sp_rasters_filled, cost, targets = target, blm = blm)

```
```{r check-results}
r_solution <- r
r_solution[] <- results$x
# Fill in the nodata
r_solution[is.na(sp_rasters[[1]])] <- NA
# make this a categorical raster
r_solution <- ratify(r_solution)
rat <- levels(r_solution)[[1]]
rat$status <- c("Not Selected", "Selected")
levels(r_solution) <- rat
levelplot(r_solution, main = "Gurobi Solution: 5% gap to optimality",
          scales = list(draw = FALSE),
          col.regions = c("grey70", "#d7191c"),
          colorkey = list(space = "bottom", height = 1))

```

## 3. Comparison of the prioritizations
