---
title: Comparing prioritization methods
date: "May 22, 2016"
output: html_notebook
---

```{r setup, echo=FALSE,message=FALSE,warning=FALSE}
library(grid)
library(gridExtra)
library(protectr)
library(raster)
library(rasterVis)
library(tidyr)
library(viridis)
library(zonator)
```

```{r function-defintions,echo=TRUE}

normalize <- function(x) {
  min <- raster::minValue(x)
  max <- raster::maxValue(x)
  return((x - min) / (max - min))
}

ol_normalize <- function(x) {
  min <- raster::minValue(x)
  return((x - min) / raster::cellStats(x - min, "sum"))
}

standardize <- function(x) {
  mean <- raster::cellStats(x, "mean")
  sd <- raster::cellStats(x, "sd", asSample = FALSE)
  return((x - mean) / sd)
}

IQRize <- function(x) {
  x_values <- raster::getValues(x)
  med <- median(x_values)
  iqr <- IQR(x_values, na.rm = TRUE)
  return((x - med) / iqr)
}

```

## 1. Setup and background

### 1.1 Zonation tutorial data

```{r read-feature,echo=TRUE}
z_tutorial_dir <- "~/dev/git-data/zonation-tutorial"
z_tutorial_data_dir <- file.path(z_tutorial_dir, "data")
tutorial_files <- list.files(path = z_tutorial_data_dir, pattern = "species.+\\.tif", 
                             full.names = TRUE)
sp_rasters <- raster::stack(tutorial_files)
# For some mysterious reasen, minmax isn't set automatically for sp_rasters[[1]]
# (species1)
sp_rasters[[1]] <- setMinMax(sp_rasters[[1]])
levelplot(sp_rasters, margin = FALSE, col.regions = viridis, layout = c(3, 3))
```

### 1.2 Geneate cost data

```{r generate-cost-data}

nrows <- nrow(sp_rasters)
ncols <- ncol(sp_rasters)

r <- extent(sp_rasters) %>% 
    raster(nrows = nrows, ncols = ncols, vals = 1)

cost <- extent(sp_rasters) %>% 
  raster(nrows = nrows, ncols = ncols, vals = 1)
#cost <- gaussian_field(r, 20, mean = 1000, variance = 500) #%>% 
#  setNames("cost")
levelplot(cost, main = "Cost", margin = FALSE, col.regions = viridis)
```

## 2. Pririoritization methods

### 2.1 Rarity-Weighted Richness (RWR)

```{r normalize-everything,echo=TRUE}
ol_sp_rasters <- ol_normalize(sp_rasters)
sum_sp_rasters <- sum(ol_sp_rasters, na.rm = TRUE)
# Replace 0 with NA
sum_sp_rasters[sum_sp_rasters ==  0] <- NA
ranks <- rank(raster::getValues(sum_sp_rasters), ties.method = "random", na.last = "keep")
# Scale to range [0, 1]
ranks <- ranks / max(ranks, na.rm = TRUE)
e <- raster::extent(sp_rasters)
rank_sp_rasters <- raster(e, nrows = nrow(sum_sp_rasters), ncols = ncol(sum_sp_rasters),
                           vals = ranks)

z_colors_spectral <- zonator::zlegend('spectral')
z_colors_RdYlBu <- z_colors_spectral
z_colors_RdYlBu$colors <- rev(brewer.pal(7, "RdYlBu"))  
```
```{r plot-rwr, echo=FALSE}
(p1 <- levelplot(rank_sp_rasters, margin = FALSE, main = "RWR",
                 par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                 at = z_colors_RdYlBu$values))
```

### 2.2 Zonation (CAZ + ABF)

```{r read-in-caz-results, echo=FALSE}
caz_rank <- raster(file.path(z_tutorial_dir, "basic", "basic_output", 
                             "01_core_area_zonation", "01_core_area_zonation.rank.asc"))
(p2 <- (levelplot(caz_rank, margin = FALSE,
                  par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                  at = z_colors_RdYlBu$values, main = "Core-area Zonation")))
```

```{r read-in-abf-results, echo=FALSE}
abf_rank <- raster(file.path(z_tutorial_dir, "basic", "basic_output", 
                             "02_additive_benefit_function", 
                             "output_02_additive_benefit_function.rank.asc"))
(p3 <- levelplot(abf_rank, margin = FALSE,
                 par.settings = rasterTheme(region = z_colors_RdYlBu$colors), 
                 at = z_colors_RdYlBu$values, main = "Additive benefit function"))
```

### 2.3 Prioritization based on Gurobi MILP


```{r optimize}

set_targets <- function(x, features, type = c("percent", "absolute")) {
  type <- match.arg(type)
  assert_that(inherits(features, "RasterStack"),
              is.numeric(x),
              length(x) == 1 || length(x) == nlayers(features))
  
  # total representation level
  total <- unname(cellStats(features, "sum"))
  if (type == "percent") {
    assert_that(all(x >= 0), all(x <= 1))
    return(x * total)
  } else {
    assert_that(length(x) == nlayers(x), all(x >= 0), all(x <= target))
    return(x)
  }
}

# From http://strimas.com/r/gurobi/

gurobi_solve <- function(features, cost, targets, blm, edge_factor = 1,
                         target_type = c("percent", "absolute"),
                         gap = 0.005, time_limit = Inf) {
  # check inputs
  assert_that(inherits(features, "RasterStack"),
              inherits(cost, "RasterLayer"),
              compareRaster(cost, features),
              is.number(blm), blm >= 0,
              is.number(edge_factor),
              is.number(gap), gap >= 0)
  
  # set proportional targets or check absolute targets
  target_type <- match.arg(target_type)
  targets <- set_targets(targets, features, type = target_type)
  # linear component of objective function
  obj <- cost[]
  if (blm > 0) {
    # calculate boundaries
    bound <- protectr::calculate_boundary(cost, sep_diagonal = TRUE)
    obj <- obj + blm * row_sums(bound$off_diagonal)
    # edge external, edge boundaries if edge_factor = 0
    if (edge_factor != 0) {
      obj <- obj + blm * edge_factor * bound$diagonal
    } 
  }
  
  # construct model
  model <- list()
  # goal is to minimize objective function
  model$modelsense <- "min"
  # binary decision variables
  model$vtype <- "B"
  # objective function
  model$obj <- obj
  if (blm > 0) {
    model$Q <- -blm * bound$off_diagonal
    rm(bound)
  }
  # structural constraints
  model$A <- as.simple_triplet_matrix(t(features[]))
  model$rhs <- targets
  model$sense <- rep('>=', length(targets))

  # set the parameters that control the algorithm
  # MIPGap controls the how close the returned solution is to optimality
  params <- list(Presolve = 2)
  if (is.finite(time_limit)) {
    params$TimeLimit = time_limit
  } else {
    params$MIPGap = gap
  }
  
  # gurobi is very RAM hungry, remove any un-needed objects
  rm(features, cost, targets, obj)
  
  # solve
  gurobi(model, params)
}

# NAs (NoData) must be raplaced wiht 0s for GUROBI
sp_rasters_filled <- sp_rasters
sp_rasters_filled[is.na(sp_rasters_filled)] <- 0
sp_rasters_filled <- raster::stack(sp_rasters_filled)

blm = 0
target = 0.1
results <- gurobi_solve(sp_rasters_filled, cost, targets = target, blm = blm)

```
```{r check-results}
r_solution <- r
r_solution[] <- results$x
# Fill in the nodata
r_solution[is.na(sp_rasters[[1]])] <- NA
# make this a categorical raster
r_solution <- ratify(r_solution)
rat <- levels(r_solution)[[1]]
rat$status <- c("Not Selected", "Selected")
levels(r_solution) <- rat
levelplot(r_solution, main = "Gurobi Solution: 5% gap to optimality",
          scales = list(draw = FALSE),
          col.regions = c("grey70", "#d7191c"),
          colorkey = list(space = "bottom", height = 1))

```

## 3. Comparison of the prioritizations

### 3.1 Qualitative spatial

```{r qualitative spatial}

# Get the top 10% solutions for RWR and Zonation
rwr_top10 <- rank_sp_rasters >= 0.9
# make this a categorical raster
rwr_top10 <- ratify(rwr_top10)
rat <- levels(rwr_top10)[[1]]
rat$status <- c("Not Selected", "Selected")
levels(rwr_top10) <- rat

abf_rank_top10 <- abf_rank >= 0.9
# make this a categorical raster
abf_rank_top10 <- ratify(abf_rank_top10)
rat <- levels(abf_rank_top10)[[1]]
rat$status <- c("Not Selected", "Selected")
levels(abf_rank_top10) <- rat

gurobi_top10 <- r_solution

p4 <- levelplot(rwr_top10, main = "RWR top 10%",
          scales = list(draw = FALSE),
          col.regions = c("grey70", "#d7191c"),
          colorkey = list(space = "bottom", height = 1))
p5 <- levelplot(abf_rank_top10, main = "Zonation ABF top 10%",
          scales = list(draw = FALSE),
          col.regions = c("grey70", "#d7191c"),
          colorkey = list(space = "bottom", height = 1))
p6 <- levelplot(r_solution, main = "Gurobi 5% gap",
          scales = list(draw = FALSE),
          col.regions = c("grey70", "#d7191c"),
          colorkey = list(space = "bottom", height = 1))

grid.arrange(p4, p5, p6, nrow = 1, ncol = 3)
```
### 3.2 Quantitative performance

```{r performance}

# Reclassify rasters
reclass_raster <- function(x, rcl) {
  
   assert_that(inherits(x, "RasterLayer"),
               inherits(rcl, "data.frame"),
               all(names(rcl) == c("from", "to", "value")))
  
  raster_rcl <- raster::reclassify(x, rcl, include.lowest = TRUE)
  raster_rcl <- ratify(raster_rcl)
  rat_rcl <- levels(raster_rcl)[[1]]
  rat_rcl$status <- rcl$value
  levels(raster_rcl) <- rat_rcl
  return(raster_rcl)
}

zonal_stats <- function(zonal_raster, values_stack, rcl, method) {
  rcl_raster <- reclass_raster(zonal_raster, rcl)
  rcl_zonal <- as.data.frame(raster::zonal(values_stack, rcl_raster, fun = 'sum'))
  # Manually add zone 0, in which nothing has been gained yet
  data_row <- rep(0, raster::nlayers(values_stack) + 1)
  names(data_row) <- c("zone", names(values_stack))
  rcl_zonal <- rbind(rcl_zonal, as.data.frame(t(data_row)))
  rcl_zonal <- rcl_zonal %>% 
    # Sort by zone, Zone 1 = 100-90% ... Zone 10 = 10-0% of the landscape
    arrange(zone) %>% 
    # Gather into long format keeping zone intact
    gather(species, value, -zone) %>%
    group_by(species) %>% 
    # Count cumulative value for distribution sum, that is zone1 + zone2 + ... + zone10
    # Then take the inverse of this, which is 1 -  dsum to show distribution remaining
    mutate(dsum = cumsum(value),
           drem = 1 - dsum) %>% 
    ungroup() %>% 
    # Finally, calculate mean distribution remaining per zone 
    group_by(zone) %>% 
    mutate(mean_drem = mean(drem), 
           method = method)
  return(rcl_zonal)
}

# Reclassification table
rcl <- data.frame(from = seq(0, .9, 0.1), 
                  to = seq(0.1, 1.0, 0.1), 
                  value = 1:10)

rwr_zonal <- zonal_stats(rank_sp_rasters, ol_sp_rasters, rcl, "RWR")
abf_zonal <- zonal_stats(abf_rank, ol_sp_rasters, rcl, "ABF")
caz_zonal <- zonal_stats(caz_rank, ol_sp_rasters, rcl, "CAZ")

# Bind all zonal stats together
all_zonal <- dplyr::bind_rows(rwr_zonal, abf_zonal, caz_zonal)

(p7 <- ggplot(rwr_zonal, aes(x = zone, y = drem, color = species)) + geom_line() + ggtitle("RWR") +
  ylab("Distribution remaining\n") + xlab("\n Landscape selected") + 
  scale_x_continuous(breaks = 0:10, labels = paste0(seq(100, 0, -10), "%")))
(p8 <- ggplot(abf_zonal, aes(x = zone, y = drem, color = species)) + geom_line() + ggtitle("ABF") +
  ylab("Distribution remaining\n") + xlab("\n Landscape selected") + 
  scale_x_continuous(breaks = 0:10, labels = paste0(seq(100, 0, -10), "%")))
(p9 <- ggplot(caz_zonal, aes(x = zone, y = drem, color = species)) + geom_line() + ggtitle("CAZ") +
  ylab("Distribution remaining\n") + xlab("\n Landscape selected") + 
  scale_x_continuous(breaks = 0:10, labels = paste0(seq(100, 0, -10), "%")))
(p10 <- ggplot(all_zonal, aes(x = zone, y = mean_drem, color = method)) + geom_line() +
  ylab("Mean distribution remaining\n") + xlab("\n Landscape selected") + 
  scale_x_continuous(breaks = 0:10, labels = paste0(seq(100, 0, -10), "%")))
```

